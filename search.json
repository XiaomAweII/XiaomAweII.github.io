[{"title":"Hello World","path":"/2024/08/27/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"文章列表测试","path":"/2023/08/27/文章列表测试1/","content":"写了一个标签tag,不知道能不能成功,让我重新上传一下 ceshi","tags":["测试"],"categories":["测试1"]},{"title":"测试第一篇文章","path":"/2023/08/27/测试第一篇文章/","content":"12System.out.println(&quot;Hello World!&quot;);int a=b 标题二标题阿斯顿 123456789101112131415161718classDiagram class Animal &#123; +String name +int age +eat() +sleep() &#125; class Dog &#123; +bark() &#125; class Cat &#123; +meow() &#125; Animal &lt;|-- Dog Animal &lt;|-- Cat","tags":["测试"],"categories":["测试1"]},{"title":"面试题(一):Java基础部分","path":"/2023/04/02/面试题(一):Java基础部分/","content":"Java基础部分面试题前言之前是看着开发者客栈的面试题花了一两个月过了一遍面试题, 但是这些背的东西时隔半年, 在我的脑海当中只有简言片语还在弥留, 打算再过一遍八股文, 结果开发者客栈里的文章有好几篇质量很高的文章只有一个题头了, 有种物是人非的感觉, 不过这种面试题的网站还是很多的, 这次计划跟着一个up主程序员鱼皮, 这位大神写的面试鸭网站进行一套面试多面手的组合拳! 面试鸭网址: https://www.mianshiya.com/开发者客栈: https://www.developers.pub/ 如果有时间的话我们也可以再看一下开发者客栈, 他基本上每道题都给出了易于理解的实例代码, 这也是我为什么很喜欢开发者客栈的原因, 毕竟理科生嘛很不喜欢死板的背, 结合实例有学而以用之的成就感 你认为的Java优势是什么? 可以从跨平台,垃圾回收,生态三个方面进行阐述 跨平台计算机当中识别的是二进制的语言, 每个平台,如macos,windows,Linux等等执行的机器码是不一样的, 所以你在这个平台写了一套程序, 在另一个平台跑起来的时候就会出现报错, 难道说我们做一套程序不能通用, 还需要每个平台写一套? 这极大增加了开发的成本, 但是Java为我们加了一层中间层JVM虚拟机, 帮助我们一次性编写, 多平台运行 编译执行过程是先把Java源代码编译成字节码, 字节码再由JVM解释或JIT编译执行, 而因为JIT编译时需要预热, 所以还提供了AOT(Ahead-of-Time Compliation), 可以直接把字节码转成机器码, 来让程序重启之后能迅速拉满战斗力 关键词 : JVM, 一次编写多平台运行, 编译执行过程 垃圾回收","tags":["面试","基础面试题","八股文"],"categories":["面试八股文"]},{"title":"仿12306售票系统编程日记(一)","path":"/2023/02/27/仿12306售票系统编程日记(一)/","content":"前言最近发现一个非常好的项目, 可以练习SpringBoot, SpringCloud微服务还有项目中令人头疼的高并发问题, 是一个技术栈非常全面的java项目. 同时最近学习完了设计模式, 但是仅限于一些简单的代码, 没有在项目当中使用过, 通过本次项目在代码编写的过程中融入设计模式, 还有查漏补缺, 把之前可能遗忘的知识点通过项目实践进行回顾…. 仿12306售票系统编程日记Day0112306 模型设计&amp;逻辑实现余票查询 : 记录站-站余票12306 出色的高并发处理性能离不开它的模型设计, 余票查询中如果按照传统的多表查询, 那么面临每秒几十万次的请求时, 答案只有一个, 立马作废. 余票查询 : 可以理解为是每两个站点之间的票进行销售, 如果购买一张长途的车票, 要做的本质上是n多张两两站点之间的售卖, 将查询变成了单表查询, 极大地提高了查询效率, 而其余余票数量也随某一站点关联增减变化 看个栗子🌰: 假设有5个站点, 分别为A, B, C, D, E, 列车行驶的方向是ABCDE, 那么可供购买的余票方案有几种呢, 这是一个小学问题: 4+3+2+1&#x3D;10种, 假设我们从A-&gt;B有10张票, 那么很显然每一种的票数都是10张, 为什么呢? 因为总共就这10个座位, 再多就只能车顶上站着吹风了! 接着, 如果我们对某两个站点之间的票进行了购买, 那么势必要对其他两个站点之间的余票数量减少, 原因是受到了影响, 有的人疑惑, 这是因为两两站点并非两个相邻站点, 明白这点肯定是理解了. 假设我们买走了A-&gt;B的票, 那么首先A-&gt;B对应的余票就应该减少1, 受到影响的A-&gt;C, A-&gt;D, A-&gt;E都会随之减少1, 这又是为什么呢, 这是因为这里的A-&gt;B, A-&gt;C, A-&gt;D, A-&gt;E不是让你提供方案, 而是已经提出的方案, 箭头两端就是两个站点, 不是原本的固定的路线, 可以参考下图理解一下: 这里往后面多画了一点, 多买了一张C-D的票, 那么按照上面的思路确实是这个样子, 但是实际上并没有这么简单, 因为我们刚才所说的10张票之所以有10张票是因为假设在这趟列车上只有10个座位, 那么就会出现第一张票A-&gt;B和第二张C-D的票购买的是否是在一个座位, 如果在同一个位置, 那么此时A-&gt;D和A-&gt;E的余票仍然是9, 这是因为当你购买第一张票的时候, 已经对A-&gt;D和A-&gt;E造成了影响, 当你再对这个座位的第二张C-&gt;D购买时, 不再对其造成影响, 但是同时会对其他的一些情况造成影响, 可以结合图看一下 通过这张图片我们可以很直观的看出来到底谁受到了影响, 简单来说就是无论座位是否相同, 影响的应该是差集, 这样就可以避免少卖, 因为库存多减少了一嘛 了解过如何避免少卖, 我们应该如何避免多买呢?我们通常可以使用简单的数据结构实现目的, 因为同一个位置, 且在相同站点之间只会有两种可能, 第一种有票, 第二种无票, 所以可以利用数字1和0表示有和没有, 那么座位1的信息在购买了A-&gt;B的余票之后, 信息可以存储为”1000”, 这样我们就可以实现余票数量的存储, 以及方便后续数据存储.","tags":["SpringBoot","微服务","高并发","项目日记","12306"],"categories":["12306售票系统"]}]