[{"title":"SpringBoot学习日记(一)","path":"/2024/09/02/SpringBoot学习日记(一)/","content":"​# SpringBoot学习日记(一) 前言在看完黑马的SpringBoot系列课程之后, 趁热打铁, 记忆还是崭新的时刻, 整理一下笔记, 方便以后查阅, 同时有不懂的地方或者理解不到位的互相学习一下.先来说一下为什么要学习SpringBoot, 这是Spring家族当中极为重要的一环, 如果开发Spring程序不用SpringBoot就是在跟自己过不去了.SpringBoot为我们开发Spring程序提供了太多的帮助, 这门技术是用来加速开发Spring程序的, 因此学习起来需要一定门槛, 就像SSM框架, Java基础部分都需要熟练掌握, 如果这些没有掌握的话, 建议先熟练掌握对应的知识, 不然无法理解Spring配合在一起工作的一对技术到底是怎么一回事, 这些搞不明白, 最终只能学个皮毛, 毫无效果. 或者学着学着就会发现其他技术不太过关, 然后就学不下去了, 然后就没有然后了. 所以要是想学好这门技术, 还是循序渐进的来.当然也可以看我的其他笔记, 如果没有的话记得联系我, 可能是上传的时候丢失或者我还没有整理出来, 我会尽量整理自己这一路学习java的艰苦历程, 自己一个人闷头学踩过很多坑, 在学习的路上能够有个人相互交流, 进步飞快, 最后, 衷心祝福大家也送给自己, 人生最重要的事情就是投资自己, 其次都是其次了, 不管前路多么漫漫, 守得云开见月明, 终有一天我们会破茧化蝶, 一起努力!!!Orz…关于学习还有一句话想送给大家, 在第一次学习的时候不必要想太深, 有时候身在其中不知其所以然, 向前走, 回头看, 会发现困扰我们的所谓的原理, 应用都会迎刃而解, 把握好自己所处的阶段, 发挥自身优势, 使得学习效率最大号-.- 快速上手SpringBoot网上的任何一门技术课程, 开篇先告诉你学习这门技术的时代背景, 多么火热, 为什么要学习, 如果大家感兴趣的话可以去网上找一下SpringBoot发展历史, 以及很多博主分析互联网的很多厂都在使用哪些技术, SpringBoot的占比多少.简单了解就是SpringBoot技术由Pivotal团队研发制作, 最主要就是加速对Spring程序的开发, 这个加速需要从两个方面来说 Spring程序的初始搭建过程 Spring程序的开发过程那这是什么意思呢? 不仅仅是我们觉得在之前搭建Spring程序的时候, 首先需要创建至少一个配置文件或者配置类, 用来配置Spring的配置信息, 然后再去写映射文件的配置信息等等, SpringBoot开发团队也认为原始的Spring程序初始搭建的时候非常繁琐, 这些用来描述Spring配置信息的文件, 可不可以不写? 此外现在企业级开发使用Spring大部分情况下是用于做web开发, 如果web开发的话, 还需要加载web环境时加载指定的spring配置, 这都是最基本的需求了, 不写的话, 他怎么知道加载哪个配置文件&#x2F;配置类呢? 那换了SpringBoot技术以后, 这些还要写吗? 一会儿我们便可以回答这个问题. SpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这些基本操作，难道这些东西SpringBoot也能帮我们简化？ SpringBoot快速构建程序(一)线面使用SpringBoot技术快速构建一个SpringMVC的程序, 通过这个过程体会**’简化’**二字的含义步骤1: 创建项目&#x2F;新模块, 选择Spring Initializr, 并配置模块相关基础信息, 如果没有的话选SpringBoot选择java版本和你当前计算机上安装的JDK版本匹配即可, 但是最低要求为JDK8或以上版本步骤2: 选择当前模块需要使用的技术集按照要求, 左侧选择web, 然后在中间技术集选择Spring Web即可, 选完后右侧出现了新的内容, 这就表示勾选成功了.此处选择的SpringBoot的版本使用默认的就可以了, 需要说一点, SpringBoot的版本升级速度很快, 可能昨天创建工程的时候默认版本是2.x.x的版本, 今天创建的工程默认版本就变成了3.x.x了, 差别不大, 也不需要纠结, 并且还可以到配置文件中修改对应的版本步骤3: 编写Controller控制类 12345678910//Rest模式@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123; @GetMapping public String getById() &#123; System.out.println(&quot;springboot is running...&quot;); return &quot;springboot is running...&quot;; &#125;&#125; 这里的SpringMVC的控制器是基于Rest风格开发, 当然此处也可以使用原始格式制作SpringMVC的程序也是一点问题没有@RestController和@RequestMapping注解就是基于Restful开发的典型注解做到这里SpringBoot程序的最基础的开发已经做完了, 现在就可以正常的运行Spring程序了. 但是我们发现Tomcat服务器没有配置, Spring也没有配置, 什么都没有配置能直接用? 这就是SpringBoot的强大之处. 之后的内部工作流程我们再娓娓道来, 先专心于SpringBoot开发的过程.步骤4: 运行自动生成的Application类使用带main方法的java程序的运行形式来运行程序, 运行完毕后, 控制台输出上述信息.可以看出, 运行的信息中包含了8080的端口, Tomcat这种熟悉的字样, 难道这里启动了Tomcat服务器? 没错, 确实已经启动, 但是服务器没有配置, 这服务器优势哪里来的呢? 不急, 先关注这种方式的启动逻辑, 我们现在就可以通过浏览器访问请求的路径, 测试功能是否工作正常了.访问路径: http://localhost:8080/books当然底层逻辑还是很复杂的, 但是我们目前可以看到只有两个文件展现到了开发者面前 pom.xml这是maven的配置文件, 描述了当前工程构建时响应的配置信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xiaoweii&lt;/groupId&gt; &lt;artifactId&gt;demo6&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo6&lt;/name&gt; &lt;description&gt;demo6&lt;/description&gt; &lt;url/&gt; &lt;licenses&gt; &lt;license/&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer/&gt; &lt;/developers&gt; &lt;scm&gt; &lt;connection/&gt; &lt;developerConnection/&gt; &lt;tag/&gt; &lt;url/&gt; &lt;/scm&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置中有两个信息需要关注，一个是parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说 Application类12345678@SpringBootApplicationpublic class Demo6Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Demo6Application.class, args); &#125;&#125; 这个类的功能很简单, 就一句代码, 前面运行程序就是运行的这个类.通过上面的制作, 发现SpringBoot程序兼职太好写了, 几乎什么都没有写, 功能就有了, 这也是SpringBoot技术为什么现在这么火的原因, 和Spring程序相比, SpringBoot在开发的过程中各个层面均具有优势 类配置文件 Spring SpringBoot pom文件中的坐标 手工添加 勾选添加 web3.0配置类 手工制作 无 Spring&#x2F;SpringMVC配置类 手工制作 无 控制器 手工制作 手工制作","tags":["SpringBoot","学习日记"],"categories":["SpringBoot学习日记"]},{"title":"Hello World","path":"/2024/08/27/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"文章列表测试","path":"/2023/08/27/文章列表测试1/","content":"写了一个标签tag,不知道能不能成功,让我重新上传一下 ceshi","tags":["测试"],"categories":["测试1"]},{"title":"测试第一篇文章","path":"/2023/08/27/测试第一篇文章/","content":"12System.out.println(&quot;Hello World!&quot;);int a=b 标题二标题阿斯顿 123456789101112131415161718classDiagram class Animal &#123; +String name +int age +eat() +sleep() &#125; class Dog &#123; +bark() &#125; class Cat &#123; +meow() &#125; Animal &lt;|-- Dog Animal &lt;|-- Cat","tags":["测试"],"categories":["测试1"]},{"title":"面试题(一):Java基础部分","path":"/2023/04/02/面试题(一):Java基础部分/","content":"Java基础部分面试题前言之前是看着开发者客栈的面试题花了一两个月过了一遍面试题, 但是这些背的东西时隔半年, 在我的脑海当中只有简言片语还在弥留, 打算再过一遍八股文, 结果开发者客栈里的文章有好几篇质量很高的文章只有一个题头了, 有种物是人非的感觉, 不过这种面试题的网站还是很多的, 这次计划跟着一个up主程序员鱼皮, 这位大神写的面试鸭网站进行一套面试多面手的组合拳! 面试鸭网址: https://www.mianshiya.com/开发者客栈: https://www.developers.pub/ 如果有时间的话我们也可以再看一下开发者客栈, 他基本上每道题都给出了易于理解的实例代码, 这也是我为什么很喜欢开发者客栈的原因, 毕竟理科生嘛很不喜欢死板的背, 结合实例有学而以用之的成就感 你认为的Java优势是什么? 可以从跨平台,垃圾回收,生态三个方面进行阐述 跨平台计算机当中识别的是二进制的语言, 每个平台,如macos,windows,Linux等等执行的机器码是不一样的, 所以你在这个平台写了一套程序, 在另一个平台跑起来的时候就会出现报错, 难道说我们做一套程序不能通用, 还需要每个平台写一套? 这极大增加了开发的成本, 但是Java为我们加了一层中间层JVM虚拟机, 帮助我们一次性编写, 多平台运行 编译执行过程是先把Java源代码编译成字节码, 字节码再由JVM解释或JIT编译执行, 而因为JIT编译时需要预热, 所以还提供了AOT(Ahead-of-Time Compliation), 可以直接把字节码转成机器码, 来让程序重启之后能迅速拉满战斗力 关键词 : JVM, 一次编写多平台运行, 编译执行过程 垃圾回收","tags":["面试","基础面试题","八股文"],"categories":["面试八股文"]},{"title":"仿12306售票系统编程日记(一)","path":"/2023/02/27/仿12306售票系统编程日记(一)/","content":"前言最近发现一个非常好的项目, 可以练习SpringBoot, SpringCloud微服务还有项目中令人头疼的高并发问题, 是一个技术栈非常全面的java项目. 同时最近学习完了设计模式, 但是仅限于一些简单的代码, 没有在项目当中使用过, 通过本次项目在代码编写的过程中融入设计模式, 还有查漏补缺, 把之前可能遗忘的知识点通过项目实践进行回顾…. 仿12306售票系统编程日记Day0112306 模型设计&amp;逻辑实现余票查询 : 记录站-站余票12306 出色的高并发处理性能离不开它的模型设计, 余票查询中如果按照传统的多表查询, 那么面临每秒几十万次的请求时, 答案只有一个, 立马作废. 余票查询 : 可以理解为是每两个站点之间的票进行销售, 如果购买一张长途的车票, 要做的本质上是n多张两两站点之间的售卖, 将查询变成了单表查询, 极大地提高了查询效率, 而其余余票数量也随某一站点关联增减变化 看个栗子🌰: 假设有5个站点, 分别为A, B, C, D, E, 列车行驶的方向是ABCDE, 那么可供购买的余票方案有几种呢, 这是一个小学问题: 4+3+2+1&#x3D;10种, 假设我们从A-&gt;B有10张票, 那么很显然每一种的票数都是10张, 为什么呢? 因为总共就这10个座位, 再多就只能车顶上站着吹风了! 接着, 如果我们对某两个站点之间的票进行了购买, 那么势必要对其他两个站点之间的余票数量减少, 原因是受到了影响, 有的人疑惑, 这是因为两两站点并非两个相邻站点, 明白这点肯定是理解了. 假设我们买走了A-&gt;B的票, 那么首先A-&gt;B对应的余票就应该减少1, 受到影响的A-&gt;C, A-&gt;D, A-&gt;E都会随之减少1, 这又是为什么呢, 这是因为这里的A-&gt;B, A-&gt;C, A-&gt;D, A-&gt;E不是让你提供方案, 而是已经提出的方案, 箭头两端就是两个站点, 不是原本的固定的路线, 可以参考下图理解一下: 这里往后面多画了一点, 多买了一张C-D的票, 那么按照上面的思路确实是这个样子, 但是实际上并没有这么简单, 因为我们刚才所说的10张票之所以有10张票是因为假设在这趟列车上只有10个座位, 那么就会出现第一张票A-&gt;B和第二张C-D的票购买的是否是在一个座位, 如果在同一个位置, 那么此时A-&gt;D和A-&gt;E的余票仍然是9, 这是因为当你购买第一张票的时候, 已经对A-&gt;D和A-&gt;E造成了影响, 当你再对这个座位的第二张C-&gt;D购买时, 不再对其造成影响, 但是同时会对其他的一些情况造成影响, 可以结合图看一下 通过这张图片我们可以很直观的看出来到底谁受到了影响, 简单来说就是无论座位是否相同, 影响的应该是差集, 这样就可以避免少卖, 因为库存多减少了一嘛 了解过如何避免少卖, 我们应该如何避免多买呢?我们通常可以使用简单的数据结构实现目的, 因为同一个位置, 且在相同站点之间只会有两种可能, 第一种有票, 第二种无票, 所以可以利用数字1和0表示有和没有, 那么座位1的信息在购买了A-&gt;B的余票之后, 信息可以存储为”1000”, 这样我们就可以实现余票数量的存储, 以及方便后续数据存储.","tags":["SpringBoot","微服务","高并发","项目日记","12306"],"categories":["12306售票系统"]}]