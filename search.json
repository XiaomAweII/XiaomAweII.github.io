[{"title":"SpringBoot学习日记(一)","path":"/2024/09/02/SpringBoot学习日记(一)/","content":"​# SpringBoot 学习日记(一) 前言在看完黑马的 SpringBoot 系列课程之后, 趁热打铁, 记忆还是崭新的时刻, 整理一下笔记, 方便以后查阅, 同时有不懂的地方或者理解不到位的互相学习一下.先来说一下为什么要学习 SpringBoot, 这是 Spring 家族当中极为重要的一环, 如果开发 Spring 程序不用 SpringBoot 就是在跟自己过不去了.SpringBoot 为我们开发 Spring 程序提供了太多的帮助, 这门技术是用来加速开发 Spring 程序的, 因此学习起来需要一定门槛, 就像 SSM 框架, Java 基础部分都需要熟练掌握, 如果这些没有掌握的话, 建议先熟练掌握对应的知识, 不然无法理解 Spring 配合在一起工作的一对技术到底是怎么一回事, 这些搞不明白, 最终只能学个皮毛, 毫无效果. 或者学着学着就会发现其他技术不太过关, 然后就学不下去了, 然后就没有然后了. 所以要是想学好这门技术, 还是循序渐进的来.当然也可以看我的其他笔记, 如果没有的话记得联系我, 可能是上传的时候丢失或者我还没有整理出来, 我会尽量整理自己这一路学习 java 的艰苦历程, 自己一个人闷头学踩过很多坑, 在学习的路上能够有个人相互交流, 进步飞快, 最后, 衷心祝福大家也送给自己, 人生最重要的事情就是投资自己, 其次都是其次了, 不管前路多么漫漫, 守得云开见月明, 终有一天我们会破茧化蝶, 一起努力!!!Orz…关于学习还有一句话想送给大家, 在第一次学习的时候不必要想太深, 有时候身在其中不知其所以然, 向前走, 回头看, 会发现困扰我们的所谓的原理, 应用都会迎刃而解, 把握好自己所处的阶段, 发挥自身优势, 使得学习效率最大号-.- 快速上手 SpringBoot网上的任何一门技术课程, 开篇先告诉你学习这门技术的时代背景, 多么火热, 为什么要学习, 如果大家感兴趣的话可以去网上找一下 SpringBoot 发展历史, 以及很多博主分析互联网的很多厂都在使用哪些技术, SpringBoot 的占比多少. 简单了解就是 SpringBoot 技术由 Pivotal 团队研发制作, 最主要就是加速对 Spring 程序的开发, 这个加速需要从两个方面来说 Spring 程序的初始搭建过程 Spring 程序的开发过程 那这是什么意思呢? 不仅仅是我们觉得在之前搭建 Spring 程序的时候, 首先需要创建至少一个配置文件或者配置类, 用来配置 Spring 的配置信息, 然后再去写映射文件的配置信息等等, SpringBoot 开发团队也认为原始的 Spring 程序初始搭建的时候非常繁琐, 这些用来描述 Spring 配置信息的文件, 可不可以不写? 此外现在企业级开发使用 Spring 大部分情况下是用于做 web 开发, 如果 web 开发的话, 还需要加载 web 环境时加载指定的 spring 配置, 这都是最基本的需求了, 不写的话, 他怎么知道加载哪个配置文件&#x2F;配置类呢? 那换了 SpringBoot 技术以后, 这些还要写吗? 一会儿我们便可以回答这个问题. SpringBoot 开发团队认为原始的 Spring 程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的 jar 包（或坐标）然后将这个技术的核心对象交给 Spring 容器管理，也就是配置成 Spring 容器管控的 bean 就可以了。这些基本操作，难道这些东西 SpringBoot 也能帮我们简化？ SpringBoot 快速构建程序(一)线面使用 SpringBoot 技术快速构建一个 SpringMVC 的程序, 通过这个过程体会简化二字的含义 步骤 1: 创建项目&#x2F;新模块, 选择 Spring Initializr, 并配置模块相关基础信息, 如果没有的话选 SpringBoot选择 java 版本和你当前计算机上安装的 JDK 版本匹配即可, 但是最低要求为 JDK8 或以上版本 步骤 2: 选择当前模块需要使用的技术集按照要求, 左侧选择 web, 然后在中间技术集选择 Spring Web 即可, 选完后右侧出现了新的内容, 这就表示勾选成功了.此处选择的 SpringBoot 的版本使用默认的就可以了, 需要说一点, SpringBoot 的版本升级速度很快, 可能昨天创建工程的时候默认版本是 2.x.x 的版本, 今天创建的工程默认版本就变成了 3.x.x 了, 差别不大, 也不需要纠结, 并且还可以到配置文件中修改对应的版本 步骤 3: 编写 Controller 控制类 12345678910//Rest模式@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123; @GetMapping public String getById() &#123; System.out.println(&quot;springboot is running...&quot;); return &quot;springboot is running...&quot;; &#125;&#125; 这里的 SpringMVC 的控制器是基于 Rest 风格开发, 当然此处也可以使用原始格式制作 SpringMVC 的程序也是一点问题没有@RestController 和@RequestMapping 注解就是基于 Restful 开发的典型注解做到这里 SpringBoot 程序的最基础的开发已经做完了, 现在就可以正常的运行 Spring 程序了. 但是我们发现 Tomcat 服务器没有配置, Spring 也没有配置, 什么都没有配置能直接用? 这就是 SpringBoot 的强大之处. 之后的内部工作流程我们再娓娓道来, 先专心于 SpringBoot 开发的过程. 步骤 4: 运行自动生成的 Application 类使用带 main 方法的 java 程序的运行形式来运行程序, 运行完毕后, 控制台输出上述信息.可以看出, 运行的信息中包含了 8080 的端口, Tomcat 这种熟悉的字样, 难道这里启动了 Tomcat 服务器? 没错, 确实已经启动, 但是服务器没有配置, 这服务器优势哪里来的呢? 不急, 先关注这种方式的启动逻辑, 我们现在就可以通过浏览器访问请求的路径, 测试功能是否工作正常了.访问路径: http://localhost:8080/books当然底层逻辑还是很复杂的, 但是我们目前可以看到只有两个文件展现到了开发者面前 pom.xml这是 maven 的配置文件, 描述了当前工程构建时响应的配置信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xiaoweii&lt;/groupId&gt; &lt;artifactId&gt;demo6&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo6&lt;/name&gt; &lt;description&gt;demo6&lt;/description&gt; &lt;url/&gt; &lt;licenses&gt; &lt;license/&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer/&gt; &lt;/developers&gt; &lt;scm&gt; &lt;connection/&gt; &lt;developerConnection/&gt; &lt;tag/&gt; &lt;url/&gt; &lt;/scm&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置中有两个信息需要关注，一个是 parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说 Application 类 12345678@SpringBootApplicationpublic class Demo6Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Demo6Application.class, args); &#125;&#125; 这个类的功能很简单, 就一句代码, 前面运行程序就是运行的这个类.通过上面的制作, 发现 SpringBoot 程序兼职太好写了, 几乎什么都没有写, 功能就有了, 这也是 SpringBoot 技术为什么现在这么火的原因, 和 Spring 程序相比, SpringBoot 在开发的过程中各个层面均具有优势 类配置文件 Spring SpringBoot pom 文件中的坐标 手工添加 勾选添加 web3.0 配置类 手工制作 无 Spring&#x2F;SpringMVC 配置类 手工制作 无 控制器 手工制作 手工制作 SpringBoot 快速构建程序(二)如果 Idea 不能正常联网，这个 SpringBoot 程序就无法制作了吗？开什么玩笑，世上 IDE 工具千千万，难道 SpringBoot 技术还必须基于 Idea 来做了？这是不可能的。开发 SpringBoot 程序，可以不基于任意的 IDE 工具进行，其实在 SpringBoot 的官网里面就可以直接创建 SpringBoot 程序 SpringBoot 官网和 Spring 的官网是在一起的，都是 spring.io 。你可以通过项目一级一级的找到 SpringBoot 技术的介绍页，然后在页面中间部位找到如下内容 步骤 1: 点击 Spring Initializr 后进入到创建 SpringBoot 程序的界面上, 下面是输入信息的过程, 和前面一样, 只是界面变了而已, 根据自己的要求, 在左侧选择对应信息和输入对应的信息即可 步骤 2: 右侧的 ADD DEPENDENCIES 用于选择使用何种技术, 和之前勾选的 Spring WEB 是在做同一件事, 仅仅是界面不同而已, 点击后打开网页版的技术选择界面 步骤 3: 所有信息设置完毕后, 点击下面左侧的按钮吗, 生成一个文件包 步骤 4: 保存后得到一个压缩文件, 这个文件打开之后就是创建 SpringBoot 工程文件夹了 步骤 5: 解压缩此文件后, 得到工程目录, 在 Idea 中导入即可使用, 和之前通过 idea 创建的东西完全一样, 下面可以自己创建一个 Controller 测试一下是否能用了 其实 idea 工具中创建 SpringBoot 工程其实连接的就是 SpringBoot 的官网, 走的就是我们在方式(二)中的这个过程, 只不过是把界面重新整合了一下, 读取到了 Spring 官网给的信息, 然后展示到了 idea 的界面中 这里连接的网址, 是不是跟 SpringBoot 官网创建工程的 URL 地址一模一样? 总结 打开 SpringBoot 官网, 选择 Quickstart Your Project 创建工程根据需要选择依赖并保存项目 解压生成的项目, 通过 IDEA 导入项目 SpringBoot 快速构建程序(三)前面提到的 https://start.spring.io 网站, 创建工程考的是访问国外的 Spring 主站, 但是有一天我们无法再访问国外的网站, 被限制了怎么办? 其实我们国内也提供了一个, 阿里提供了一个这样子的网站, 我们只需要将 starter 服务路径在创建工程时进行修改, 即可使用阿里云为我们提供的服务啦. 手动输入 http://start.aliyun.com 或 https://start.aliyun.com 阿里云提供的地址更符合国内开发者的使用习惯, 里面有一些 SpringBoot 官网上没有给出的坐标, 同时使用阿里云提供的工程创建地址初始化完毕后使用 SpringBoot 官网创建出来的工程略有区别. 主要是在配置配件的形式上有区别. 具体区别看 Boot 程序的执行流程, 不做过多赘述. SpringBoot 快速构建程序(四)如果有一天, 你进到一个国企, 或者保密程度比较高的组织, 你无法连接外部的网络, 你又该如何启动一个 SpringBoot 工程呢? 其实显而易见, 就是提前下好, 创建的时候拷贝上去, 简而言之, 就是把要联网干的事情都提前准备好.那么我们联网的时候需要做什么呢? 首先我们使用 SpringBoot 工程也是基于 Maven 构建的, 而 Maven 工程当使用了一些自己需要使用又不存在的东西时, 就要去下载. 其实 SpringBoot 工程创建的时候就是去下载一些必要的组件的. 把这些提前准备好久完全 ok 了 步骤 1: 创建工程时, 选择手工创建 Maven 工程 步骤 2: 参照标准 SpringBoot 工程的 pom 文件, 书写字节的 pom 文件即可 1234567891011121314151617181920212223242526272829303132333435&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.xiaoweii&lt;/groupId&gt; &lt;artifactId&gt;untitled&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;untitled&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 步骤 3: 之前运行 SpringBoot 工程需要一个类, 这个缺不了, 自己手写一个就行了, 建议按照之前的目录结构来创建 123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(&lt;Application.class); &#125;&#125; 类上面的注解@SpringBootApplication 是核心, 一定要写类名可以自定义, 只要保障下面代码中使用的类名和自己定义的名称一样即可, 也就是 run 方法中的那个 class 对应的名称 步骤 4: 下面就可以自己创建一个 Controller 测试一下是否能够使用 无论通过通过 idea 向导还是通过网站创建的 SpringBoot 工程其实就是帮你写了一些代码, 而现在是自己手写, 内容都一样, 没有什么区别 如果之前没有创建成功过 SpringBoot 工程, 自然也就没有下载过 SpringBoot 对应的坐标, 那用手写创建的方式在不联网的情况下肯定是不能用的. 所谓手写, 其实就是自己写别人帮你生成的东西, 但是引用的坐标对应的资源必须保障 maven 仓库里面有才行, 如果没有, 还是要去下载的 多学一手: 在 idea 中隐藏指定文件&#x2F;文件夹创建 SpringBoot 工程的时候, 无论使用那种方式, 最终都是为了一个目的, 得到一个标准的 SpringBoot 工程文件结构. 这个时候就有新的问题出现了, 标准的工程结构中包含了一些未知的文件夹, 在开发的时候看起来特别别扭, 这一节就来说说这些文件怎么处理.处理方案无外乎两种, 如果你对每一个文件&#x2F;目录足够了解, 没有用的完全可以删除掉, 或者不删除, 但是看着别扭, 就设置文件看不到就行了. 删除就不说了, 直接 Delete 掉就好了, 下面我们演示一下如何隐藏指定的文件或文件夹信息步骤 1: 打开 idea 设置,【Files】→【Settings】 步骤 2: 打开文件类型设置界面，【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示 步骤 3: 添加你要隐藏的文件名称或文件夹名称，可以使用*号通配符，表示任意，设置完毕即可 SpringBoot 简介到这里, 我们初始创建制作的过程就结束了, 我们再来回顾一下 SpringBoot 的功能是什么? 用于加速 Spring 程序的开发, 现在是否深有体会? 那么所谓简化 Spring 应用的初始搭建以及开发过程, 都简化了哪些东西呢? 其实主要是针对原始的 Spring 程序制作的两个方面进行了简化: Spring 程序缺点: 依赖设置繁琐以前写 Spring 程序, 使用的技术都要自己一个一个的写, 现在不需要了, 如果做过 SpringMVC 程序的小伙伴应该知道, 写 SpringMVC 程序, 最基础的 spring-web 和 spring-webmvc 这两个坐标是必须的, 就这还不包含使用 json 等等坐标, 现在一个坐标搞定 配置繁琐以前写配置类或者配置文件, 然后用什么东西都需要自己写加载 bean 这些东西, 现在呢? 什么都没写, 照样能用 对于 Spring 程序的不足之处, SpringBoot 给出了极大的简化, 这些简化操作在 SpringBoot 中有专业的用于, 也是 SpringBoot 程序的核心功能和优点: 起步依赖（简化依赖配置） 依赖配置的书写简化就是靠这个起步依赖达成的 自动配置（简化常用工程相关配置） 配置过于繁琐，使用自动配置就可以做响应的简化，但是内部还是很复杂的，后面具体展开说 辅助功能（内置服务器，……） 除了上面的功能，其实 SpringBoot 程序还有其他的一些优势，比如我们没有配置 Tomcat 服务器，但是能正常运行，这是 SpringBoot 程序的一个可以感知到的功能，也是 SpringBoot 的辅助功能之一。一个辅助功能都能做的这么 6，太牛了 接下来我们结合上面创建的程序来说说简化操作在哪些方面进行体现, 一共分为 4 个方面 parent starter 引导类 内嵌 tomcat parentSpringBoot 关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如 A 技术的 2.0 版与 B 技术的 3.5 版可以合作在一起，但是和 B 技术的 3.7 版合并使用时就有冲突。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。 SpringBoot 一看这种情况 so easy 啊，于是将所有的技术版本的常见使用方案都给开发者整理了出来，以后开发者使用时直接用它提供的版本方案，就不用担心冲突问题了，相当于 SpringBoot 做了无数个技术版本搭配的列表，这个技术搭配列表的名字叫做parent parent自身具有很多个版本, 每个parent版本中包含有几百个其他技术的版本号, 不同的 parent 间使用的各种技术的版本号有可能会发生变化. 当开发者使用某些技术时, 直接使用 SpringBoot 提供的 parent 就行了, 由parent帮助开发者统一的进行各种技术的版本管理 比如你现在要使用 Spring 配合 MyBatis 开发，没有 parent 之前怎么做呢？选个 Spring 的版本，再选个 MyBatis 的版本，再把这些技术使用时关联的其他技术的版本逐一确定下来。当你 Spring 的版本发生变化需要切换时，你的 MyBatis 版本有可能也要跟着切换，关联技术呢？可能都要切换，而且切换后还可能出现问题。现在这一切工作都可以交给 parent 来做了。你无需关注这些技术间的版本冲突问题, 你只需要关注你用什么技术就行了, 冲突问题由parent负责处理 有人可能会提出来，万一parent给我导入了一些我不想使用的依赖怎么办？记清楚，这一点很关键，parent仅仅帮我们进行版本管理，它不负责帮你导入坐标，说白了用什么还是你自己定，只不过版本不需要你管理了。整体上来说，使用 parent 可以帮助开发者进行版本的统一管理 也就是说, parent定义出来以后, 并不是直接使用的, 仅仅给了开发者一个说明书, 但是并没有实际使用, 这个一定要确认清除 那 SpringBoot 又是如何做到这一点呢? 我们意义查阅 SpringBoot 的配置源码, 看到这些定义 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt;&lt;/parent&gt; 我们可以去到你自己的仓库,或者直接打开后可以查阅到其中又继承了一个坐标 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt;&lt;/parent&gt; 这个坐标中定义了两组信息, 第一组是各式各样的依赖版本号, 下面列出依赖版本属性的局部, 可以看的出来, 定义了若干技术的依赖版本号 123456789101112131415161718192021&lt;properties&gt; &lt;activemq.version&gt;6.1.3&lt;/activemq.version&gt; &lt;angus-mail.version&gt;2.0.3&lt;/angus-mail.version&gt; &lt;artemis.version&gt;2.33.0&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.9.22.1&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.25.3&lt;/assertj.version&gt; &lt;awaitility.version&gt;4.2.2&lt;/awaitility.version&gt; &lt;zipkin-reporter.version&gt;3.4.0&lt;/zipkin-reporter.version&gt; &lt;brave.version&gt;6.0.3&lt;/brave.version&gt; &lt;build-helper-maven-plugin.version&gt;3.5.0&lt;/build-helper-maven-plugin.version&gt; &lt;byte-buddy.version&gt;1.14.19&lt;/byte-buddy.version&gt; &lt;cache2k.version&gt;2.6.1.Final&lt;/cache2k.version&gt; &lt;caffeine.version&gt;3.1.8&lt;/caffeine.version&gt; &lt;cassandra-driver.version&gt;4.18.1&lt;/cassandra-driver.version&gt; &lt;classmate.version&gt;1.7.0&lt;/classmate.version&gt; &lt;commons-codec.version&gt;1.16.1&lt;/commons-codec.version&gt; &lt;commons-dbcp2.version&gt;2.12.0&lt;/commons-dbcp2.version&gt; &lt;commons-lang3.version&gt;3.14.0&lt;/commons-lang3.version&gt; &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt; ......&lt;/properties&gt; 第二组是各式各样的的依赖坐标信息，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值 1234567891011121314151617181920212223242526&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-console&lt;/artifactId&gt; &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 上面的依赖坐标定义是出现在标签中的，其实是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组parent信息后，在不使用对应坐标的情况下，前面的这组定义是不会具体导入某个依赖的 因为在maven中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的starter创建工程时就使用了此种形式 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 总结 开发SpringBoot程序要继承spring-boot-starter-parent spring-boot-starter-parent中定义了若干个依赖管理 继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突 继承parent的形式也可以采用引入依赖的形式实现效果 starterparent中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？ SpringBoot关注到开发者在实际开发时，对于依赖坐标的使用往往都有一些固定的组合方式，比如使用spring-webmvc就一定要使用spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。 SpringBoot一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用一次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot给它起了个名字叫做starter starter定义了使用某种技术时对于依赖的固定搭配格式, 可以帮助开发者减少依赖配置.","tags":["SpringBoot","学习日记"],"categories":["SpringBoot学习日记"]},{"title":"Hello World","path":"/2024/08/27/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"文章列表测试","path":"/2023/08/27/文章列表测试1/","content":"写了一个标签tag,不知道能不能成功,让我重新上传一下 ceshi","tags":["测试"],"categories":["测试1"]},{"title":"测试第一篇文章","path":"/2023/08/27/测试第一篇文章/","content":"12System.out.println(&quot;Hello World!&quot;);int a=b 标题二标题阿斯顿 123456789101112131415161718classDiagram class Animal &#123; +String name +int age +eat() +sleep() &#125; class Dog &#123; +bark() &#125; class Cat &#123; +meow() &#125; Animal &lt;|-- Dog Animal &lt;|-- Cat","tags":["测试"],"categories":["测试1"]},{"title":"面试题(一):Java基础部分","path":"/2023/04/02/面试题(一):Java基础部分/","content":"Java基础部分面试题前言之前是看着开发者客栈的面试题花了一两个月过了一遍面试题, 但是这些背的东西时隔半年, 在我的脑海当中只有简言片语还在弥留, 打算再过一遍八股文, 结果开发者客栈里的文章有好几篇质量很高的文章只有一个题头了, 有种物是人非的感觉, 不过这种面试题的网站还是很多的, 这次计划跟着一个up主程序员鱼皮, 这位大神写的面试鸭网站进行一套面试多面手的组合拳! 面试鸭网址: https://www.mianshiya.com/开发者客栈: https://www.developers.pub/ 如果有时间的话我们也可以再看一下开发者客栈, 他基本上每道题都给出了易于理解的实例代码, 这也是我为什么很喜欢开发者客栈的原因, 毕竟理科生嘛很不喜欢死板的背, 结合实例有学而以用之的成就感 你认为的Java优势是什么? 可以从跨平台,垃圾回收,生态三个方面进行阐述 跨平台计算机当中识别的是二进制的语言, 每个平台,如macos,windows,Linux等等执行的机器码是不一样的, 所以你在这个平台写了一套程序, 在另一个平台跑起来的时候就会出现报错, 难道说我们做一套程序不能通用, 还需要每个平台写一套? 这极大增加了开发的成本, 但是Java为我们加了一层中间层JVM虚拟机, 帮助我们一次性编写, 多平台运行 编译执行过程是先把Java源代码编译成字节码, 字节码再由JVM解释或JIT编译执行, 而因为JIT编译时需要预热, 所以还提供了AOT(Ahead-of-Time Compliation), 可以直接把字节码转成机器码, 来让程序重启之后能迅速拉满战斗力 关键词 : JVM, 一次编写多平台运行, 编译执行过程 垃圾回收","tags":["面试","基础面试题","八股文"],"categories":["面试八股文"]},{"title":"仿12306售票系统编程日记(一)","path":"/2023/02/27/仿12306售票系统编程日记(一)/","content":"前言最近发现一个非常好的项目, 可以练习SpringBoot, SpringCloud微服务还有项目中令人头疼的高并发问题, 是一个技术栈非常全面的java项目. 同时最近学习完了设计模式, 但是仅限于一些简单的代码, 没有在项目当中使用过, 通过本次项目在代码编写的过程中融入设计模式, 还有查漏补缺, 把之前可能遗忘的知识点通过项目实践进行回顾…. 仿12306售票系统编程日记Day0112306 模型设计&amp;逻辑实现余票查询 : 记录站-站余票12306 出色的高并发处理性能离不开它的模型设计, 余票查询中如果按照传统的多表查询, 那么面临每秒几十万次的请求时, 答案只有一个, 立马作废. 余票查询 : 可以理解为是每两个站点之间的票进行销售, 如果购买一张长途的车票, 要做的本质上是n多张两两站点之间的售卖, 将查询变成了单表查询, 极大地提高了查询效率, 而其余余票数量也随某一站点关联增减变化 看个栗子🌰: 假设有5个站点, 分别为A, B, C, D, E, 列车行驶的方向是ABCDE, 那么可供购买的余票方案有几种呢, 这是一个小学问题: 4+3+2+1&#x3D;10种, 假设我们从A-&gt;B有10张票, 那么很显然每一种的票数都是10张, 为什么呢? 因为总共就这10个座位, 再多就只能车顶上站着吹风了! 接着, 如果我们对某两个站点之间的票进行了购买, 那么势必要对其他两个站点之间的余票数量减少, 原因是受到了影响, 有的人疑惑, 这是因为两两站点并非两个相邻站点, 明白这点肯定是理解了. 假设我们买走了A-&gt;B的票, 那么首先A-&gt;B对应的余票就应该减少1, 受到影响的A-&gt;C, A-&gt;D, A-&gt;E都会随之减少1, 这又是为什么呢, 这是因为这里的A-&gt;B, A-&gt;C, A-&gt;D, A-&gt;E不是让你提供方案, 而是已经提出的方案, 箭头两端就是两个站点, 不是原本的固定的路线, 可以参考下图理解一下: 这里往后面多画了一点, 多买了一张C-D的票, 那么按照上面的思路确实是这个样子, 但是实际上并没有这么简单, 因为我们刚才所说的10张票之所以有10张票是因为假设在这趟列车上只有10个座位, 那么就会出现第一张票A-&gt;B和第二张C-D的票购买的是否是在一个座位, 如果在同一个位置, 那么此时A-&gt;D和A-&gt;E的余票仍然是9, 这是因为当你购买第一张票的时候, 已经对A-&gt;D和A-&gt;E造成了影响, 当你再对这个座位的第二张C-&gt;D购买时, 不再对其造成影响, 但是同时会对其他的一些情况造成影响, 可以结合图看一下 通过这张图片我们可以很直观的看出来到底谁受到了影响, 简单来说就是无论座位是否相同, 影响的应该是差集, 这样就可以避免少卖, 因为库存多减少了一嘛 了解过如何避免少卖, 我们应该如何避免多买呢?我们通常可以使用简单的数据结构实现目的, 因为同一个位置, 且在相同站点之间只会有两种可能, 第一种有票, 第二种无票, 所以可以利用数字1和0表示有和没有, 那么座位1的信息在购买了A-&gt;B的余票之后, 信息可以存储为”1000”, 这样我们就可以实现余票数量的存储, 以及方便后续数据存储.","tags":["SpringBoot","微服务","高并发","项目日记","12306"],"categories":["12306售票系统"]}]