[{"title":"阿里云服务器上搭建数据库","path":"/2024/09/04/阿里云服务器上搭建数据库/","content":"在阿里云服务器上搭建数据库和源 IP 访问可以通过以下几个步骤进行 安装数据库我搭建的是 MySQL 数据库, 因为最常用嘛, 回头可以试一下其他的 1234567891011121314# 更新包列表sudo apt update# 安装MySQLsudo apt install mysql-server# 启动MySQL服务sudo systemctl start mysql#设置MySQL开机启动sudo systemctl enable mysql# 运行安全脚本sudo mysql_secure_installation 配置 MySQL 远程访问编辑 MySQL 配置文件 1sudo nano /etc/mysql/mysql.conf.d/mysqld.cnf 找到 bind-address 行, 将其修改为 1bind-address 因为如果你的端口号想要修改, 因为 3306 确实容易被攻击和勒索 那就让他攻击吧, 坚决不付费, 随时保存你的 sql 结构文件而且可以使用阿里云快照服务同时可以修改常用端口号 1port = 你想用的端口号 重启 MySQL 服务 1sudo systemctl restart mysql 创建远程访问用户登录 MySQL 1sudo mysql -u root -p 创建用户并授权 123CREATE USER &#x27;你的远端连接用户&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;你的密码&#x27;;GRANT ALL PRIVILEGES ON *.* TO &#x27;你的远端连接用户&#x27;@&#x27;%&#x27;;FLUSH PRIVILEGES; 下面用 remoteuser 和 remotepassword 代替 配置阿里云安全组 登录到阿里云控制台(点击右上角头像, 然后进入到用户界面, 控制台在该界面左上角) 进入 ECS 实例列表 选择你想要操作的实例 -&gt; 更多 -&gt; 网络和安全组 -&gt; 安全组配置 点击”配置规则” -&gt; “添加安全组规则” 添加入方向规则: 授权策略: 允许 协议类型: MySQL(3306), 或者自定义 TCP 端口范围: 3306&#x2F;3306 或者 你自己定义的端口号, 修改了要去配置文件当中也修改, 根据上边的操作 授权对象: 您的源 IP 地址(如果是所有 IP,可以填写 0.0.0.0&#x2F;0,但不推荐), 你也可以 ip-config 查看自己电脑 ip, 进行写入, 当然这样也就你可以访问了 配置服务器防火墙如果使用的是 UFW(Ubuntu 默认防火墙) 12sudo ufw allow 3306sudo ufw enable 如果修改了端口, 那么就填你自己的端口 测试连接从你的电脑本地机器或允许的 ip 地址, 使用 MySQL 客户端工具尝试连接 1mysql -h your_server_ip -u remoteuser -p 然后输入摩玛 如果修改了端口范围 修改 MySQL 配置文件 1sudo nano /etc/mysql/mysql.conf.d/mysqld.cnf 找到 port 行（如果没有就添加），将其修改为： 1port = 你的端口号 重启 MySQL 服务 1sudo systemctl restart mysql 然后重复去阿里云安全组当中配置, 修改或添加端口, 如果不想 3306 被访问的话, 可以删除 更新防火墙规则 123sudo ufw delete allow 3306 # 删除旧规则（如果存在）sudo ufw allow 你的端口号sudo ufw enable 测试连接 1mysql -h your_server_ip -P 你的端口号 -u remoteuser -p 其他查看服务器 MySQL 监听端口号1sudo netstat -tlnp | grep mysql 远程访问设置给你对应的用户赋予权限, 确保你使用的用户存在且权限正确, 有权进行远程连接 服务器状态确保 MySQL 服务正在运行\\ 1sudo systemctl status mysql 网络连接检查如果还是不行, 查看是有有网, 可以尝试 pint 或者 telnet, 确保本地机器可以访问到阿里云服务器的 ip 地址 12ping 你的服务器公网iptelnet 你的服务器公网ip 你的端口号 用户权限确保用户有权限可以从任何主机连接 1select User, Host from mysql.user where User = &#x27;你的用户名&#x27;; 应该能看到 Host 列为% 错误日志检查 MySQL 的错误日志, 获取到更多可用信息, 方便解决 1sudo tail -f /var/log/mysql/error.log 临时测试如果还是无法连接，可以临时将 MySQL 配置为监听所有接口，并重启服务 12sudo sed -i &#x27;s/bind-address.*/bind-address = 0.0.0.0/&#x27; /etc/mysql/mysql.conf.d/mysqld.cnfsudo systemctl restart mysql 检查书写错误检查连接字符串 1mysql -h 你的服务器公网ip -P 你的端口号 -u 你的用户名 -p你的密码","tags":["阿里云","云服务器","数据库"],"categories":["云服务器搭建数据库"]},{"title":"数据库的like模糊查询如何优化","path":"/2024/09/03/数据库的like模糊查询如何优化/","content":"场景在MySQL中, LIKE模糊查询可能会导致性能问题, 使用通配符%开头时, 将不会使用索引进行查询, 因为这会导致全表扫描 解决方案合理使用索引前缀匹配: 使用 like &#39;prefix%&#39; 的形式, 通配符在开头会影响索引导致全表扫描, 那我们就把他放后边不就好了, 比如 1select * from users where username like &#x27;Abc%&#x27;; 这样子的话, 如果 username 字段有索引, 前缀匹配就会用到索引 使用反向索引但是有时候确实需要我们使用后缀匹配(即 like &#39;%suffix&#39;), 那么我们就可以创建一个辅助队列存储反转字符串, 并基于辅助队列进行前缀匹配, 这样我们又回到了第一种情况, 就又可以通过索引进行查询 创建反向字符串: 123alter table users add reversed_username varchar(255);update users set reversed_username = reverse(username);create index idx_reversed_username on users(reversed_username); 限制扫描范围在 like 查询中, 如果可以通过其他条件进一步缩小范围, 也可以实现对模糊查询进行优化, 查询时尽量加入这些条件 1select * from users where created_at &gt;= &#x27;2022-03-01&#x27; and username like &#x27;Abc%&#x27;; 使用缓存如果对于相同的查询需要频繁执行, 可以考虑在应用层实施缓存策略来减少数据库负载, 这一部分可以去看MyBatis的缓存的章节, MyBatis在这一块做的特别好 同时也可以借助于像REDIS这样的缓存, 提升查询性能, 前提是这些数据不是经常变化的数据, 我们也可以开启cache去看一下缓存命中率 借助专业工具对于非常大的数据集或者需要复杂文本处理和搜索功能, 可以外部全文搜索引擎 Elasticsearch , Solr 或者 Sphinx 来代替MySQL的like操作, 这几个工具我还没怎么使用过, 我操作的数据最多有过几千条, 还是缺乏经验, 碰见的太少了, 抽时间压力测试一下, 找个工具练练. 总结通过以上这些方法优化 like 查询, 可以显著提升数据库的查询性能, 应根据具体场景选择合适的优化策略. 使用explain分析查询执行计划, 可以帮助确认优化效果","tags":["like","模糊查询","MySQL","mysql","数据库优化"],"categories":["MySQl数据库优化"]},{"title":"SpringBoot学习日记(二)","path":"/2024/09/02/SpringBoot学习日记(二)/","content":"SpringBoot 基础配置快速制作 SpringBoot 学完了, 下面就要研究 SpringBoot 的用法了. 通过上一章, 想必能够感受到一个信息, 就是 SpringBoot 没有具体的功能, 它在辅助加快 Spring 程序的开发效率。我们发现现在几乎不用做任何的配置，功能就有了，确实很好用。但是仔细想想，没有做配置意味着什么？意味着配置已经做好了，不用你自己写了。但是新的问题又来了，如果不想用已经写好的默认配置，该如何干预呢？这就是这一章咱们要研究的问题。 如果我们想修改默认的配置 i，这个信息应该写在什么位置呢？目前我们接触到的一共有 3 个文件, 第一是 pom.xml 文件，设置项目的依赖的，这个没什么好研究的，相关的高级内容咱们到原理篇再说，第二是引导类，这个是执行 SpringBoot 程序的入口，也不像是做配置的地方，其实还有一个信息，就是在 resources 目录下面有一个空白的文件，叫做 application.properties。一看就是个配置文件，咱们这一章就来说说配置文件怎么写，能写什么，怎么干预 SpringBoot 的默认配置，修改成自己的配置。 属性配置SpringBoot 通过配置文件 application.properties 就可以修改默认的配置，那咱们就先找个简单的配置下手，当前访问 tomcat 的默认端口是 8080，好熟悉的味道，但是不便于书写，我们先改成 80，通过这个操作来熟悉一下 SpringBoot 的配置格式是什么样的 那该如何写呢? properties 格式的文件书写规范是 key&#x3D;value 1name=xxx 我们尝试性的修改一下端口号, 写 port. 当输入 port 后, 会发现他带提示!! 20240902172024 根据提示敲回车, 输入 80 端口, 搞定 下面再次运行程序, 测试效果 然后会发现我们的端口的确变成了 80, 回想一下, 以前修改端口在哪里修改? tomcat 服务器的配置文件中改，现在呢？SpringBoot 专用的配置文件中改，是不是意味着以后所有的配置都可以写在这一个文件中呢？是的，简化开发者配置的书写位置，集中管理。妙啊，妈妈再也不用担心我找不到配置文件了。 其实到这里我们应该得到如下三个信息 SpringBoot 程序可以在 application.properties 文件中进行属性配置 application.properties 文件中只要输入要配置的属性关键字就可以根据提示进行设置 SpringBoot 将配置信息集中在一个文件中写，不管你是服务器的配置，还是数据库的配置，总之都写在一起，逃离一个项目十几种配置文件格式的尴尬局面 练习可以进行一些尝试 关闭运行日志图标(banner) 1spring.main.banner-mode=off 设置运行日志的显示级别 1logging.level.root=debug 这些配置是按照一定规范进行书写, 如果想要查看更多的属性, 可以打开 SpringBoot 的官网, 找到 SpringBoot 官方文档, 打开查看附录中的 Application Properties 就可以获取到对应的配置项了，网址奉上：https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties 能写什么的问题解决了, 再来说第二个问题, 这个配置项和什么有关. 在 pom 中注释掉导入的 spring-boot-starter-web，然后刷新工程，你会发现配置的提示消失了。闹了半天是设定使用了什么技术才能做什么配置。也合理，不然配置的东西都没有使用对应技术，配了也是白配。 所有的 starter 中都会依赖下面这个 starter，叫做 spring-boot-starter。这个 starter 是所有的 SpringBoot 的 starter 的基础依赖，里面定义了 SpringBoot 相关的基础配置，关于这个 starter 我们在之后再深入讲解。 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.5.7&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 配置文件分类SpringBoot 除了支持 properties 格式的配置文件，还支持另外两种格式的配置文件。分别如下: properties 格式 (传统格式&#x2F;默认格式) yml 格式 (主流格式) yaml 格式 一看到全新的文件格式，各位小伙伴肯定想，这下又要学习新的语法格式了。怎么说呢？从知识角度来说，要学，从开发角度来说，不用学。为什么呢？因为 SpringBoot 的配置在 Idea 工具下有提示啊，跟着提示走就行了。下面列举三种不同文件格式配置相同的属性范例，先了解一下 application.properties（properties 格式） 1server.port=80 application.yml（yml 格式） 12server: port: 81 application.yaml（yaml 格式） 12server: port: 82 仔细看会发现 yml 格式和 yaml 格式除了文件名后缀不一样，格式完全一样，是这样的，yml 和 yaml 文件格式就是一模一样的，只是文件后缀不同，所以可以合并成一种格式来看。那对于这三种格式来说，以后用哪一种比较多呢？记清楚，以后基本上都是用 yml 格式的，本课程后面的所有知识都是基于 yml 格式来制作的，以后在企业开发过程中用这个格式的机会也最多，一定要重点掌握。 配置文件优先级在指导三种格式都可以做配置之后, 如果都写了, 谁的优先级更高呢? 其实三个文件如果共存的话，谁生效说的就是配置文件加载的优先级别。先说一点，虽然以后这种情况很少出现，但是这个知识还是可以学习一下的。我们就让三个配置文件书写同样的信息，比如都配置端口，然后我们让每个文件配置的端口号都不一样，最后启动程序后看启动端口是多少就知道谁的加载优先级比较高了。 application.properties（properties 格式） 1server.port=80 application.yml（yml 格式） 12server: port: 81 application.yaml（yaml 格式） 12server: port: 82 启动后发现目前的启动端口为 80，把 80 对应的文件删除掉，然后再启动，现在端口又改成了 81。现在我们就已经知道了 3 个文件的加载优先顺序是什么 1application.properties &gt; application.yml &gt; application.yaml 虽然得到了一个知识结论，但是我们实际开发的时候还是要看最终的效果为准。也就是你要的最终效果是什么自己是明确的，上述结论只能帮助你分析结论产生的原因。这个知识了解一下就行了，因为以后同时写多种配置文件格式的情况实在是较少。 最后我们把配置文件内容给修改一下 application.properties（properties 格式） 12server.port=80spring.main.banner-mode=off application.yml（yml 格式） 12345server: port: 81logging: level: root: debug application.yaml（yaml 格式） 12server: port: 82 我们发现不仅端口生效了，最终显示 80，同时其他两条配置也生效了，看来每个配置文件中的项都会生效，只不过如果多个配置文件中有相同类型的配置会优先级高的文件覆盖优先级的文件中的配置。如果配置项不同的话，那所有的配置项都会生效。 所以说, 配置文件间的加载优先级 properties（最高）&gt; yml &gt; yaml（最低）,且不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留 yaml 文件SpringBoot 的配置以后主要使用 yml 结尾的这种文件格式，并且在书写时可以通过提示的形式加载正确的格式。但是这种文件还是有严格的书写格式要求的。下面就来说一下具体的语法格式。 YAML（YAML Ain’t Markup Language），一种数据序列化格式。具有容易阅读、容易与脚本语言交互、以数据为核心，重数据轻格式的特点。常见的文件扩展名有两种： .yml 格式（主流） .yaml 格式 具体的语法格式要求如下： 大小写敏感 属性层级关系使用多行描述，每行结尾使用冒号结束 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用 Tab 键） 属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔） #号 表示注释 上述规则不要死记硬背，按照书写习惯慢慢适应，并且在 Idea 下由于具有提示功能，慢慢适应着写格式就行了。核心的一条规则要记住，数据前面要加空格与冒号隔开。 常见的数据书写格式 12345678boolean: TRUE #TRUE,true,True,FALSE,false，False均可float: 3.14 #6.8523015e+5 #支持科学计数法int: 123 #0b1010_0111_0100_1010_1110 #支持二进制、八进制、十六进制null: ~ #使用~表示nullstring: HelloWorld #字符串可以直接书写string2: &quot;Hello World&quot; #可以使用双引号包裹特殊字符date: 2018-02-17 #日期必须使用yyyy-MM-dd格式datetime: 2018-02-17T15:02:31+08:00 #时间和日期之间使用T连接，最后使用+代表时区 此外，yaml 格式中也可以表示数组，在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔。 12345678910111213141516171819202122232425subject:\t- Java\t- 前端\t- 大数据enterprise:\tname: itcast age: 16 subject: - Java - 前端 - 大数据likes: [王者荣耀,刺激战场] #数组书写缩略格式users: #对象数组格式一 - name: Tom age: 4 - name: Jerry age: 5users: #对象数组格式二 - name: Tom age: 4 - name: Jerry age: 5users2: [ &#123; name:Tom , age:4 &#125; , &#123; name:Jerry , age:5 &#125; ]\t#对象数组缩略格式 yaml 数据读取对于 yaml 文件中的数据，其实你就可以想象成这就是一个小型的数据库，里面保存有若干数据，每个数据都有一个独立的名字，如果你想读取里面的数据，肯定是支持的，下面就介绍 3 种读取数据的方式。 读取单一数据yaml 中保存的单个数据，可以使用 Spring 中的注解@Value 读取单个数据，属性名引用方式：${一级属性名.二级属性名……} 记得使用@Value 注解时，要将该注解写在某一个指定的 Spring 管控的 bean 的属性名上方，这样当 bean 进行初始化时候就可以读取到对应的单一数据了。使用@Value 配合 SpEL 读取单个数据, 如果数据存在多层级，依次书写层级名称即可 读取全部数据读取单一数据可以解决读取数据的问题，但是如果定义的数据量过大，这么一个一个书写肯定会累死人的，SpringBoot 提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做 Environment，使用自动装配注解可以将所有的 yaml 数据封装到这个对象中 数据封装到了 Environment 对象中，获取属性时，通过 Environment 的接口操作进行，具体方法是 getProperties（String），参数填写属性名即可 使用 Environment 对象封装全部配置信息, 使用@Autowired 自动装配数据到 Environment 对象中 读取对象数据单一数据读取书写比较繁琐，全数据读取封装的太厉害了，每次拿数据还要一个一个的 getProperties（）,总之用起来都不是很舒服。由于 Java 是一个面向对象的语言，很多情况下，我们会将一组数据封装成一个对象。SpringBoot 也提供了可以将一组 yaml 对象数据封装一个 Java 对象的操作 首先定义一个对象，并将该对象纳入 Spring 管控的范围，也就是定义成一个 bean，然后使用注解@ConfigurationProperties 指定该对象加载哪一组 yaml 中配置的信息。 这个@ConfigurationProperties 必须告诉他加载的数据前缀是什么，这样指定前缀下的所有属性就封装到这个对象中。记得数据属性名要与对象的变量名一一对应啊，不然没法封装。其实以后如果你要定义一组数据自己使用，就可以先写一个对象，然后定义好属性，下面到配置中根据这个格式书写即可。 细心的小伙伴会发现一个问题，自定义的这种数据在 yaml 文件中书写时没有弹出提示，咱们到原理篇再揭秘如何弹出提示。 使用@ConfigurationProperties 注解绑定配置信息到封装类中, 封装类需要定义为 Spring 管理的 bean，否则无法进行属性注入 yaml 文件中的数据引用如果你在书写 yaml 数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀 12345center:\tdataDir: /usr/local/fire/data tmpDir: /usr/local/fire/tmp logDir: /usr/local/fire/log msgDir: /usr/local/fire/msgDir 或者 12345center:\tdataDir: D:/usr/local/fire/data tmpDir: D:/usr/local/fire/tmp logDir: D:/usr/local/fire/log msgDir: D:/usr/local/fire/msgDir 这个时候你可以使用引用格式来定义数据，其实就是搞了个变量名，然后引用变量了，格式如下： 123456baseDir: /usr/local/firecenter: dataDir: $&#123;baseDir&#125;/data tmpDir: $&#123;baseDir&#125;/tmp logDir: $&#123;baseDir&#125;/log msgDir: $&#123;baseDir&#125;/msgDir 还有一个注意事项，在书写字符串时，如果需要使用转义字符，需要将数据字符串使用双引号包裹起来 1lesson: &quot;Spring\\tboot lesson&quot;","tags":["SpringBoot","学习日记"],"categories":["SpringBoot学习日记"]},{"title":"SpringBoot学习日记(一)","path":"/2024/09/02/SpringBoot学习日记(一)/","content":"前言在看完黑马的 SpringBoot 系列课程之后, 趁热打铁, 记忆还是崭新的时刻, 整理一下笔记, 方便以后查阅, 同时有不懂的地方或者理解不到位的互相学习一下.先来说一下为什么要学习 SpringBoot, 这是 Spring 家族当中极为重要的一环, 如果开发 Spring 程序不用 SpringBoot 就是在跟自己过不去了.SpringBoot 为我们开发 Spring 程序提供了太多的帮助, 这门技术是用来加速开发 Spring 程序的, 因此学习起来需要一定门槛, 就像 SSM 框架, Java 基础部分都需要熟练掌握, 如果这些没有掌握的话, 建议先熟练掌握对应的知识, 不然无法理解 Spring 配合在一起工作的一对技术到底是怎么一回事, 这些搞不明白, 最终只能学个皮毛, 毫无效果. 或者学着学着就会发现其他技术不太过关, 然后就学不下去了, 然后就没有然后了. 所以要是想学好这门技术, 还是循序渐进的来.当然也可以看我的其他笔记, 如果没有的话记得联系我, 可能是上传的时候丢失或者我还没有整理出来, 我会尽量整理自己这一路学习 java 的艰苦历程, 自己一个人闷头学踩过很多坑, 在学习的路上能够有个人相互交流, 进步飞快, 最后, 衷心祝福大家也送给自己, 人生最重要的事情就是投资自己, 其次都是其次了, 不管前路多么漫漫, 守得云开见月明, 终有一天我们会破茧化蝶, 一起努力!!!Orz…关于学习还有一句话想送给大家, 在第一次学习的时候不必要想太深, 有时候身在其中不知其所以然, 向前走, 回头看, 会发现困扰我们的所谓的原理, 应用都会迎刃而解, 把握好自己所处的阶段, 发挥自身优势, 使得学习效率最大化-.- 快速上手 SpringBoot网上的任何一门技术课程, 开篇先告诉你学习这门技术的时代背景, 多么火热, 为什么要学习, 如果大家感兴趣的话可以去网上找一下 SpringBoot 发展历史, 以及很多博主分析互联网的很多厂都在使用哪些技术, SpringBoot 的占比多少. 简单了解就是 SpringBoot 技术由 Pivotal 团队研发制作, 最主要就是加速对 Spring 程序的开发, 这个加速需要从两个方面来说 Spring 程序的初始搭建过程 Spring 程序的开发过程 那这是什么意思呢? 不仅仅是我们觉得在之前搭建 Spring 程序的时候, 首先需要创建至少一个配置文件或者配置类, 用来配置 Spring 的配置信息, 然后再去写映射文件的配置信息等等, SpringBoot 开发团队也认为原始的 Spring 程序初始搭建的时候非常繁琐, 这些用来描述 Spring 配置信息的文件, 可不可以不写? 此外现在企业级开发使用 Spring 大部分情况下是用于做 web 开发, 如果 web 开发的话, 还需要加载 web 环境时加载指定的 spring 配置, 这都是最基本的需求了, 不写的话, 他怎么知道加载哪个配置文件&#x2F;配置类呢? 那换了 SpringBoot 技术以后, 这些还要写吗? 一会儿我们便可以回答这个问题. SpringBoot 开发团队认为原始的 Spring 程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的 jar 包（或坐标）然后将这个技术的核心对象交给 Spring 容器管理，也就是配置成 Spring 容器管控的 bean 就可以了。这些基本操作，难道这些东西 SpringBoot 也能帮我们简化？ SpringBoot 快速构建程序(一)下面使用 SpringBoot 技术快速构建一个 SpringMVC 的程序, 通过这个过程体会简化二字的含义 步骤 1: 创建项目&#x2F;新模块, 选择 Spring Initializr, 并配置模块相关基础信息, 如果没有的话选 SpringBoot选择 java 版本和你当前计算机上安装的 JDK 版本匹配即可, 但是最低要求为 JDK8 或以上版本 步骤 2: 选择当前模块需要使用的技术集按照要求, 左侧选择 web, 然后在中间技术集选择 Spring Web 即可, 选完后右侧出现了新的内容, 这就表示勾选成功了.此处选择的 SpringBoot 的版本使用默认的就可以了, 需要说一点, SpringBoot 的版本升级速度很快, 可能昨天创建工程的时候默认版本是 2.x.x 的版本, 今天创建的工程默认版本就变成了 3.x.x 了, 差别不大, 也不需要纠结, 并且还可以到配置文件中修改对应的版本 步骤 3: 编写 Controller 控制类 12345678910//Rest模式@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123; @GetMapping public String getById() &#123; System.out.println(&quot;springboot is running...&quot;); return &quot;springboot is running...&quot;; &#125;&#125; 这里的 SpringMVC 的控制器是基于 Rest 风格开发, 当然此处也可以使用原始格式制作 SpringMVC 的程序也是一点问题没有@RestController 和@RequestMapping 注解就是基于 Restful 开发的典型注解做到这里 SpringBoot 程序的最基础的开发已经做完了, 现在就可以正常的运行 Spring 程序了. 但是我们发现 Tomcat 服务器没有配置, Spring 也没有配置, 什么都没有配置能直接用? 这就是 SpringBoot 的强大之处. 之后的内部工作流程我们再娓娓道来, 先专心于 SpringBoot 开发的过程. 步骤 4: 运行自动生成的 Application 类使用带 main 方法的 java 程序的运行形式来运行程序, 运行完毕后, 控制台输出上述信息.可以看出, 运行的信息中包含了 8080 的端口, Tomcat 这种熟悉的字样, 难道这里启动了 Tomcat 服务器? 没错, 确实已经启动, 但是服务器没有配置, 这服务器优势哪里来的呢? 不急, 先关注这种方式的启动逻辑, 我们现在就可以通过浏览器访问请求的路径, 测试功能是否工作正常了.访问路径: http://localhost:8080/books当然底层逻辑还是很复杂的, 但是我们目前可以看到只有两个文件展现到了开发者面前 pom.xml这是 maven 的配置文件, 描述了当前工程构建时响应的配置信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xiaoweii&lt;/groupId&gt; &lt;artifactId&gt;demo6&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo6&lt;/name&gt; &lt;description&gt;demo6&lt;/description&gt; &lt;url/&gt; &lt;licenses&gt; &lt;license/&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer/&gt; &lt;/developers&gt; &lt;scm&gt; &lt;connection/&gt; &lt;developerConnection/&gt; &lt;tag/&gt; &lt;url/&gt; &lt;/scm&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置中有两个信息需要关注，一个是 parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说 Application 类 12345678@SpringBootApplicationpublic class Demo6Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Demo6Application.class, args); &#125;&#125; 这个类的功能很简单, 就一句代码, 前面运行程序就是运行的这个类.通过上面的制作, 发现 SpringBoot 程序兼职太好写了, 几乎什么都没有写, 功能就有了, 这也是 SpringBoot 技术为什么现在这么火的原因, 和 Spring 程序相比, SpringBoot 在开发的过程中各个层面均具有优势 类配置文件 Spring SpringBoot pom 文件中的坐标 手工添加 勾选添加 web3.0 配置类 手工制作 无 Spring&#x2F;SpringMVC 配置类 手工制作 无 控制器 手工制作 手工制作 SpringBoot 快速构建程序(二)如果 Idea 不能正常联网，这个 SpringBoot 程序就无法制作了吗？开什么玩笑，世上 IDE 工具千千万，难道 SpringBoot 技术还必须基于 Idea 来做了？这是不可能的。开发 SpringBoot 程序，可以不基于任意的 IDE 工具进行，其实在 SpringBoot 的官网里面就可以直接创建 SpringBoot 程序 SpringBoot 官网和 Spring 的官网是在一起的，都是 spring.io 。你可以通过项目一级一级的找到 SpringBoot 技术的介绍页，然后在页面中间部位找到如下内容 步骤 1: 点击 Spring Initializr 后进入到创建 SpringBoot 程序的界面上, 下面是输入信息的过程, 和前面一样, 只是界面变了而已, 根据自己的要求, 在左侧选择对应信息和输入对应的信息即可 步骤 2: 右侧的 ADD DEPENDENCIES 用于选择使用何种技术, 和之前勾选的 Spring WEB 是在做同一件事, 仅仅是界面不同而已, 点击后打开网页版的技术选择界面 步骤 3: 所有信息设置完毕后, 点击下面左侧的按钮吗, 生成一个文件包 步骤 4: 保存后得到一个压缩文件, 这个文件打开之后就是创建 SpringBoot 工程文件夹了 步骤 5: 解压缩此文件后, 得到工程目录, 在 Idea 中导入即可使用, 和之前通过 idea 创建的东西完全一样, 下面可以自己创建一个 Controller 测试一下是否能用了 其实 idea 工具中创建 SpringBoot 工程其实连接的就是 SpringBoot 的官网, 走的就是我们在方式(二)中的这个过程, 只不过是把界面重新整合了一下, 读取到了 Spring 官网给的信息, 然后展示到了 idea 的界面中 这里连接的网址, 是不是跟 SpringBoot 官网创建工程的 URL 地址一模一样? 总结 打开 SpringBoot 官网, 选择 Quickstart Your Project 创建工程根据需要选择依赖并保存项目 解压生成的项目, 通过 IDEA 导入项目 SpringBoot 快速构建程序(三)前面提到的 https://start.spring.io 网站, 创建工程考的是访问国外的 Spring 主站, 但是有一天我们无法再访问国外的网站, 被限制了怎么办? 其实我们国内也提供了一个, 阿里提供了一个这样子的网站, 我们只需要将 starter 服务路径在创建工程时进行修改, 即可使用阿里云为我们提供的服务啦. 手动输入 http://start.aliyun.com 或 https://start.aliyun.com 阿里云提供的地址更符合国内开发者的使用习惯, 里面有一些 SpringBoot 官网上没有给出的坐标, 同时使用阿里云提供的工程创建地址初始化完毕后使用 SpringBoot 官网创建出来的工程略有区别. 主要是在配置配件的形式上有区别. 具体区别看 Boot 程序的执行流程, 不做过多赘述. SpringBoot 快速构建程序(四)如果有一天, 你进到一个国企, 或者保密程度比较高的组织, 你无法连接外部的网络, 你又该如何启动一个 SpringBoot 工程呢? 其实显而易见, 就是提前下好, 创建的时候拷贝上去, 简而言之, 就是把要联网干的事情都提前准备好.那么我们联网的时候需要做什么呢? 首先我们使用 SpringBoot 工程也是基于 Maven 构建的, 而 Maven 工程当使用了一些自己需要使用又不存在的东西时, 就要去下载. 其实 SpringBoot 工程创建的时候就是去下载一些必要的组件的. 把这些提前准备好久完全 ok 了 步骤 1: 创建工程时, 选择手工创建 Maven 工程 步骤 2: 参照标准 SpringBoot 工程的 pom 文件, 书写字节的 pom 文件即可 1234567891011121314151617181920212223242526272829303132333435&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.xiaoweii&lt;/groupId&gt; &lt;artifactId&gt;untitled&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;untitled&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 步骤 3: 之前运行 SpringBoot 工程需要一个类, 这个缺不了, 自己手写一个就行了, 建议按照之前的目录结构来创建 123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(&lt;Application.class); &#125;&#125; 类上面的注解@SpringBootApplication 是核心, 一定要写类名可以自定义, 只要保障下面代码中使用的类名和自己定义的名称一样即可, 也就是 run 方法中的那个 class 对应的名称 步骤 4: 下面就可以自己创建一个 Controller 测试一下是否能够使用 无论通过通过 idea 向导还是通过网站创建的 SpringBoot 工程其实就是帮你写了一些代码, 而现在是自己手写, 内容都一样, 没有什么区别 如果之前没有创建成功过 SpringBoot 工程, 自然也就没有下载过 SpringBoot 对应的坐标, 那用手写创建的方式在不联网的情况下肯定是不能用的. 所谓手写, 其实就是自己写别人帮你生成的东西, 但是引用的坐标对应的资源必须保障 maven 仓库里面有才行, 如果没有, 还是要去下载的 多学一手: 在 idea 中隐藏指定文件&#x2F;文件夹创建 SpringBoot 工程的时候, 无论使用那种方式, 最终都是为了一个目的, 得到一个标准的 SpringBoot 工程文件结构. 这个时候就有新的问题出现了, 标准的工程结构中包含了一些未知的文件夹, 在开发的时候看起来特别别扭, 这一节就来说说这些文件怎么处理.处理方案无外乎两种, 如果你对每一个文件&#x2F;目录足够了解, 没有用的完全可以删除掉, 或者不删除, 但是看着别扭, 就设置文件看不到就行了. 删除就不说了, 直接 Delete 掉就好了, 下面我们演示一下如何隐藏指定的文件或文件夹信息步骤 1: 打开 idea 设置,【Files】→【Settings】 步骤 2: 打开文件类型设置界面，【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示 步骤 3: 添加你要隐藏的文件名称或文件夹名称，可以使用*号通配符，表示任意，设置完毕即可 SpringBoot 简介到这里, 我们初始创建制作的过程就结束了, 我们再来回顾一下 SpringBoot 的功能是什么? 用于加速 Spring 程序的开发, 现在是否深有体会? 那么所谓简化 Spring 应用的初始搭建以及开发过程, 都简化了哪些东西呢? 其实主要是针对原始的 Spring 程序制作的两个方面进行了简化: Spring 程序缺点: 依赖设置繁琐以前写 Spring 程序, 使用的技术都要自己一个一个的写, 现在不需要了, 如果做过 SpringMVC 程序的小伙伴应该知道, 写 SpringMVC 程序, 最基础的 spring-web 和 spring-webmvc 这两个坐标是必须的, 就这还不包含使用 json 等等坐标, 现在一个坐标搞定 配置繁琐以前写配置类或者配置文件, 然后用什么东西都需要自己写加载 bean 这些东西, 现在呢? 什么都没写, 照样能用 对于 Spring 程序的不足之处, SpringBoot 给出了极大的简化, 这些简化操作在 SpringBoot 中有专业的用于, 也是 SpringBoot 程序的核心功能和优点: 起步依赖（简化依赖配置） 依赖配置的书写简化就是靠这个起步依赖达成的 自动配置（简化常用工程相关配置） 配置过于繁琐，使用自动配置就可以做响应的简化，但是内部还是很复杂的，后面具体展开说 辅助功能（内置服务器，……） 除了上面的功能，其实 SpringBoot 程序还有其他的一些优势，比如我们没有配置 Tomcat 服务器，但是能正常运行，这是 SpringBoot 程序的一个可以感知到的功能，也是 SpringBoot 的辅助功能之一。一个辅助功能都能做的这么 6，太牛了 接下来我们结合上面创建的程序来说说简化操作在哪些方面进行体现, 一共分为 4 个方面 parent starter 引导类 内嵌 tomcat parentSpringBoot 关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如 A 技术的 2.0 版与 B 技术的 3.5 版可以合作在一起，但是和 B 技术的 3.7 版合并使用时就有冲突。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。 SpringBoot 一看这种情况 so easy 啊，于是将所有的技术版本的常见使用方案都给开发者整理了出来，以后开发者使用时直接用它提供的版本方案，就不用担心冲突问题了，相当于 SpringBoot 做了无数个技术版本搭配的列表，这个技术搭配列表的名字叫做parent parent自身具有很多个版本, 每个parent版本中包含有几百个其他技术的版本号, 不同的 parent 间使用的各种技术的版本号有可能会发生变化. 当开发者使用某些技术时, 直接使用 SpringBoot 提供的 parent 就行了, 由parent帮助开发者统一的进行各种技术的版本管理 比如你现在要使用 Spring 配合 MyBatis 开发，没有 parent 之前怎么做呢？选个 Spring 的版本，再选个 MyBatis 的版本，再把这些技术使用时关联的其他技术的版本逐一确定下来。当你 Spring 的版本发生变化需要切换时，你的 MyBatis 版本有可能也要跟着切换，关联技术呢？可能都要切换，而且切换后还可能出现问题。现在这一切工作都可以交给 parent 来做了。你无需关注这些技术间的版本冲突问题, 你只需要关注你用什么技术就行了, 冲突问题由parent负责处理 有人可能会提出来，万一parent给我导入了一些我不想使用的依赖怎么办？记清楚，这一点很关键，parent仅仅帮我们进行版本管理，它不负责帮你导入坐标，说白了用什么还是你自己定，只不过版本不需要你管理了。整体上来说，使用 parent 可以帮助开发者进行版本的统一管理 也就是说, parent定义出来以后, 并不是直接使用的, 仅仅给了开发者一个说明书, 但是并没有实际使用, 这个一定要确认清除 那 SpringBoot 又是如何做到这一点呢? 我们意义查阅 SpringBoot 的配置源码, 看到这些定义 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt;&lt;/parent&gt; 我们可以去到你自己的仓库,或者直接打开后可以查阅到其中又继承了一个坐标 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt;&lt;/parent&gt; 这个坐标中定义了两组信息, 第一组是各式各样的依赖版本号, 下面列出依赖版本属性的局部, 可以看的出来, 定义了若干技术的依赖版本号 123456789101112131415161718192021&lt;properties&gt; &lt;activemq.version&gt;6.1.3&lt;/activemq.version&gt; &lt;angus-mail.version&gt;2.0.3&lt;/angus-mail.version&gt; &lt;artemis.version&gt;2.33.0&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.9.22.1&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.25.3&lt;/assertj.version&gt; &lt;awaitility.version&gt;4.2.2&lt;/awaitility.version&gt; &lt;zipkin-reporter.version&gt;3.4.0&lt;/zipkin-reporter.version&gt; &lt;brave.version&gt;6.0.3&lt;/brave.version&gt; &lt;build-helper-maven-plugin.version&gt;3.5.0&lt;/build-helper-maven-plugin.version&gt; &lt;byte-buddy.version&gt;1.14.19&lt;/byte-buddy.version&gt; &lt;cache2k.version&gt;2.6.1.Final&lt;/cache2k.version&gt; &lt;caffeine.version&gt;3.1.8&lt;/caffeine.version&gt; &lt;cassandra-driver.version&gt;4.18.1&lt;/cassandra-driver.version&gt; &lt;classmate.version&gt;1.7.0&lt;/classmate.version&gt; &lt;commons-codec.version&gt;1.16.1&lt;/commons-codec.version&gt; &lt;commons-dbcp2.version&gt;2.12.0&lt;/commons-dbcp2.version&gt; &lt;commons-lang3.version&gt;3.14.0&lt;/commons-lang3.version&gt; &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt; ......&lt;/properties&gt; 第二组是各式各样的的依赖坐标信息，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值 1234567891011121314151617181920212223242526&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-console&lt;/artifactId&gt; &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 上面的依赖坐标定义是出现在标签中的，其实是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组 parent 信息后，在不使用对应坐标的情况下，前面的这组定义是不会具体导入某个依赖的 因为在 maven 中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的 starter 创建工程时就使用了此种形式 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 总结 开发 SpringBoot 程序要继承 spring-boot-starter-parent spring-boot-starter-parent 中定义了若干个依赖管理 继承 parent 模块可以避免多个依赖使用相同技术时出现依赖版本冲突 继承 parent 的形式也可以采用引入依赖的形式实现效果 starterparent 中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？ SpringBoot 关注到开发者在实际开发时，对于依赖坐标的使用往往都有一些固定的组合方式，比如使用 spring-webmvc 就一定要使用 spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。 SpringBoot 一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用一次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot 给它起了个名字叫做starter starter 定义了使用某种技术时对于依赖的固定搭配格式, 可以帮助开发者减少依赖配置. 项目中的 pom.xml 定义了使用 SpringMVC 技术，但是并没有写 SpringMVC 的坐标，而是添加了一个名字中包含 starter 的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 在 spring-boot-starter-web 中又定义了若干个具体依赖的坐标 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;6.1.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;6.1.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 之前提到过开发 SpringMVC 程序需要导入 spring-webmvc 的坐标和 spring 整合 web 开发的坐标，就是上面这组坐标中的最后两个了。 ​ 但是我们发现除了这两个还有其他的，比如第二个，叫做 spring-boot-starter-json。看名称就知道，这个是与 json 有关的坐标了，但是看名字发现和最后两个又不太一样，它的名字中也有 starter，打开看看里面有什么？ 1234567891011121314151617181920212223242526272829303132333435363738&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;6.1.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.17.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt; &lt;version&gt;2.17.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;2.17.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;version&gt;2.17.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 我们可以发现，这个 starter 中又包含了若干个坐标，其实就是使用 SpringMVC 开发通常都会使用到 Json，使用 json 又离不开这里面定义的这些坐标，看来还真是方便，SpringBoot 把我们开发中使用的东西能用到的都给提前做好了。你仔细看完会发现，里面有一些你没用过的。的确会出现这种过量导入的可能性，没关系，可以通过 maven 中的排除依赖剔除掉一部分。不过你不管它也没事，大不了就是过量导入呗。 ​ 到这里基本上得到了一个信息，使用 starter 可以帮开发者快速配置依赖关系。以前写依赖 3 个坐标的，现在写导入一个就搞定了，就是加速依赖配置的。 starter 与 parent 的区别朦朦胧胧中感觉 starter 与 parent 好像都是帮助我们简化配置的，但是功能又不一样，梳理一下。 starter是一个坐标中定了若干个坐标，以前写多个的，现在写一个，是用来减少依赖配置的书写量的 parent是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由 SpringBoot 统一管理，这样就不存在版本冲突了，是用来减少依赖冲突的 实际开发应用方式 实际开发中如果需要用什么技术，先去找有没有这个技术对应的 starter 如果有对应的 starter，直接写 starter，而且无需指定版本，版本由 parent 提供 如果没有对应的 starter，手写坐标即可 实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖 SpringBoot 提供给我们的配置管理 方式一：直接写坐标 方式二：覆盖中定义的版本号，就是下面这堆东西了，哪个冲突了覆盖哪个就 OK 了 1234567891011121314151617181920&lt;properties&gt; &lt;activemq.version&gt;5.16.3&lt;/activemq.version&gt; &lt;aspectj.version&gt;1.9.7&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.19.0&lt;/assertj.version&gt; &lt;commons-codec.version&gt;1.15&lt;/commons-codec.version&gt; &lt;commons-dbcp2.version&gt;2.8.0&lt;/commons-dbcp2.version&gt; &lt;commons-lang3.version&gt;3.12.0&lt;/commons-lang3.version&gt; &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt; &lt;commons-pool2.version&gt;2.9.0&lt;/commons-pool2.version&gt; &lt;h2.version&gt;1.4.200&lt;/h2.version&gt; &lt;hibernate.version&gt;5.4.32.Final&lt;/hibernate.version&gt; &lt;hibernate-validator.version&gt;6.2.0.Final&lt;/hibernate-validator.version&gt; &lt;httpclient.version&gt;4.5.13&lt;/httpclient.version&gt; &lt;jackson-bom.version&gt;2.12.4&lt;/jackson-bom.version&gt; &lt;javax-jms.version&gt;2.0.1&lt;/javax-jms.version&gt; &lt;javax-json.version&gt;1.1.4&lt;/javax-json.version&gt; &lt;javax-websocket.version&gt;1.1&lt;/javax-websocket.version&gt; &lt;jetty-el.version&gt;9.0.48&lt;/jetty-el.version&gt; &lt;junit.version&gt;4.13.2&lt;/junit.version&gt;&lt;/properties&gt; SpringBoot 官方给出了好多个 starter 的定义，方便我们使用，而且名称都是如下格式 1命名规则：spring-boot-starter-技术名称 所以以后见了 spring-boot-starter-aaa 这样的名字，这就是 SpringBoot 官方给出的 starter 定义。那非官方定义的也有吗？有的，具体命名方式到整合章节再说 总结 开发 SpringBoot 程序需要导入坐标时通常导入对应的 starter 每个不同的 starter 根据功能不同，通常包含多个依赖坐标 使用 starter 可以实现快速配置的效果，达到简化配置的目的 引导类配置说完了, 下面说一下程序是如何运行的. 目前程序运行的入口就是 SpringBoot 工程创建时自带的那个类, 带有 main 方法的那个类, 运行这个类就可以启动 SpringBoot 工程的运行. 123456@SpringBootApplicationpublic class Springboot0101QuickstartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot0101QuickstartApplication.class, args); &#125;&#125; SpringBoot 本身是为了加速 Spring 程序的开发的，而 Spring 程序运行的基础是需要创建自己的 Spring 容器对象（IoC 容器）并将所有的对象交给 Spring 的容器管理，也就是一个一个的 Bean。那还了 SpringBoot 加速开发 Spring 程序，这个容器还在吗？这个疑问不用说，一定在。当前这个类运行后就会产生一个 Spring 容器对象，并且可以将这个对象保存起来，通过容器对象直接操作 Bean。 12345678@SpringBootApplicationpublic class Springboot0101QuickstartApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext ctx = SpringApplication.run(Springboot0101QuickstartApplication.class, args); BookController bean = ctx.getBean(BookController.class); System.out.println(&quot;bean======&gt;&quot; + bean); &#125;&#125; 通过上述操作不难看出, 其实 SpringBoot 程序启动还是创建了一个 Spring 容器对象. 这个类在 SpringBoot 程序中是所有功能的入口, 称这个类为引导类 作为一个引导类最典型的特征就是当前类上方声明了一个注解@SpringBootApplication 总结 SpringBoot 工程提供引导类用来启动程序 SpringBoot 工程启动后创建并初始化 Spring 容器 内嵌 tomcat我们明显启动了一个 web 服务器, 可是我们的服务器是在哪里写的呢?当我们在创建 SpringBoot 项目的时候, 勾选了 Spring Web 的功能, 并且导入了对应的 starter, 我们就写好了这个服务器 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot 发现，既然你要做 web 程序，肯定离不开使用 web 服务器，这样吧，帮人帮到底，送佛送到西。我帮你搞一个 web 服务器，你要愿意用的，直接使用就好了，干脆我再多给你几种选择，你随便切换。万一你不想用我给你提供的，也行，你可以自己搞。 ​ 由于这个功能不属于程序的主体功能，可用可不用，于是乎 SpringBoot 将其定位成辅助功能，别小看这么一个辅助功能，它可是帮我们开发者又减少了好多的设置性工作。 下面我们就围绕着这个内置的 web 服务器，也可以说是内置的 tomcat 服务器来研究几个问题: 这个服务器在什么位置定义的 这个服务器是怎么运行的 这个服务器如果想换怎么换？虽然这个需求很垃圾，搞得开发者会好多 web 服务器一样，用别人提供好的不香么？非要自己折腾 内置 Tomcat 定义位置说到定义的位置，我们就想，如果我们不开发 web 程序，用的着 web 服务器吗？肯定用不着啊。那如果这个东西被加入到你的程序中，伴随着什么技术进来的呢？肯定是 web 相关的功能啊，没错，就是前面导入的 web 相关的 starter 做的这件事。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 打开查看 web 的 starter 导入了哪些东西 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;version&gt;2.7.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.7.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.3.22&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.22&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 第三个依赖就是这个 tomcat 对应的东西了, 居然也是一个 starter, 再打开看看 1234567891011121314151617181920212223242526272829303132333435363738&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;9.0.65&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;tomcat-annotations-api&lt;/artifactId&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt; &lt;version&gt;9.0.65&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt; &lt;version&gt;9.0.65&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;tomcat-annotations-api&lt;/artifactId&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 这里面有一个核心的坐标，tomcat-embed-core，叫做 tomcat 内嵌核心。就是这个东西把 tomcat 功能引入到了我们的程序中。目前解决了第一个问题，找到根儿了，谁把 tomcat 引入到程序中的？spring-boot-starter-web中的spring-boot-starter-tomcat做的。之所以你感觉很奇妙的原因就是，这个东西是默认加入到程序中了，所以感觉很神奇，居然什么都不做，就有了 web 服务器对应的功能，再来说第二个问题，这个服务器是怎么运行的 内嵌 Tomcat 运行原理Tomcat 服务器是一款软件，而且是一款使用 java 语言开发的软件，熟悉的小伙伴可能有印象，tomcat 安装目录中保存有 jar，好多个 jar。 ​ 下面的问题来了，既然是使用 java 语言开发的，运行的时候肯定符合 java 程序运行的原理，java 程序运行靠的是什么？对象呀，一切皆对象，万物皆对象。那 tomcat 运行起来呢？也是对象。 ​ 如果是对象，那 Spring 容器是用来管理对象的，这个对象能不能交给 Spring 容器管理呢？把吗去掉，是个对象都可以交给 Spring 容器管理，行了，这下通了。tomcat 服务器运行其实是以对象的形式在 Spring 容器中运行的，怪不得我们没有安装这个 tomcat，而且还能用。闹了半天这东西最后是以一个对象的形式存在，保存在 Spring 容器中悄悄运行的。具体运行的是什么呢？其实就是上前面提到的那个 tomcat 内嵌核心 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;9.0.65&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;tomcat-annotations-api&lt;/artifactId&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 那既然是个对象，如果把这个对象从 Spring 容器中去掉是不是就没有 web 服务器的功能呢？是这样的，通过依赖排除可以去掉这个 web 服务器功能 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 上面对 web-starter 做了一个操作，使用 maven 的排除依赖去掉了使用 tomcat 的 starter。这下好了，容器中肯定没有这个对象了，重新启动程序可以观察到程序运行了，但是并没有像之前那样运行后会等着用户发请求，而是直接停掉了，就是这个原因了。 更换内嵌 Tomcat那根据上面的操作我们思考是否可以换个服务器呢？必须的嘛。根据 SpringBoot 的工作机制，用什么技术，加入什么依赖就行了。SpringBoot 提供了 3 款内置的服务器 tomcat(默认)：apache 出品，粉丝多，应用面广，负载了若干较重的组件 jetty：更轻量级，负载性能远不及 tomcat undertow：负载性能勉强跑赢 tomcat 想用哪个, 加个坐标就 OK, 前提是把 tomcat 排除掉, 因为 tomcat 是默认加载的 12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 现在就已经成功替换了 web 服务器，核心思想就是用什么加入对应坐标就可以了。如果有 starter，优先使用 starter。 总结 内嵌 Tomcat 服务器是 SpringBoot 辅助功能之一 内嵌 Tomcat 工作原理是将 Tomcat 服务器作为对象运行，并将该对象交给 Spring 容器管理 变更内嵌服务器思想是去除现有服务器，添加全新的服务器 到这里”快速上手 SpringBoot”就结束了，这一章我们学习了两大块知识 使用了 4 种方式制作了 SpringBoot 的入门程序，不管是哪一种，其实内部都是一模一样的 学习了入门程序的工作流程，知道什么是 parent，什么是 starter，这两个东西是怎么配合工作的，以及我们的程序为什么启动起来是一个 tomcat 服务器等等 再往下学习就要去基于会创建 SpringBoot 工程的基础上，研究 SpringBoot 工程的具体细节了。","tags":["SpringBoot","学习日记"],"categories":["SpringBoot学习日记"]},{"title":"Hello World","path":"/2024/08/27/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"文章列表测试","path":"/2023/08/27/文章列表测试1/","content":"写了一个标签tag,不知道能不能成功,让我重新上传一下 ceshi","tags":["测试"],"categories":["测试1"]},{"title":"测试第一篇文章","path":"/2023/08/27/测试第一篇文章/","content":"12System.out.println(&quot;Hello World!&quot;);int a=b 标题二标题阿斯顿 123456789101112131415161718classDiagram class Animal &#123; +String name +int age +eat() +sleep() &#125; class Dog &#123; +bark() &#125; class Cat &#123; +meow() &#125; Animal &lt;|-- Dog Animal &lt;|-- Cat","tags":["测试"],"categories":["测试1"]},{"title":"面试题(一):Java基础部分","path":"/2023/04/02/面试题(一):Java基础部分/","content":"Java基础部分面试题前言之前是看着开发者客栈的面试题花了一两个月过了一遍面试题, 但是这些背的东西时隔半年, 在我的脑海当中只有简言片语还在弥留, 打算再过一遍八股文, 结果开发者客栈里的文章有好几篇质量很高的文章只有一个题头了, 有种物是人非的感觉, 不过这种面试题的网站还是很多的, 这次计划跟着一个up主程序员鱼皮, 这位大神写的面试鸭网站进行一套面试多面手的组合拳! 面试鸭网址: https://www.mianshiya.com/开发者客栈: https://www.developers.pub/ 如果有时间的话我们也可以再看一下开发者客栈, 他基本上每道题都给出了易于理解的实例代码, 这也是我为什么很喜欢开发者客栈的原因, 毕竟理科生嘛很不喜欢死板的背, 结合实例有学而以用之的成就感 你认为的Java优势是什么? 可以从跨平台,垃圾回收,生态三个方面进行阐述 跨平台计算机当中识别的是二进制的语言, 每个平台,如macos,windows,Linux等等执行的机器码是不一样的, 所以你在这个平台写了一套程序, 在另一个平台跑起来的时候就会出现报错, 难道说我们做一套程序不能通用, 还需要每个平台写一套? 这极大增加了开发的成本, 但是Java为我们加了一层中间层JVM虚拟机, 帮助我们一次性编写, 多平台运行 编译执行过程是先把Java源代码编译成字节码, 字节码再由JVM解释或JIT编译执行, 而因为JIT编译时需要预热, 所以还提供了AOT(Ahead-of-Time Compliation), 可以直接把字节码转成机器码, 来让程序重启之后能迅速拉满战斗力 关键词 : JVM, 一次编写多平台运行, 编译执行过程 垃圾回收","tags":["面试","基础面试题","八股文"],"categories":["面试八股文"]},{"title":"仿12306售票系统编程日记(一)","path":"/2023/02/27/仿12306售票系统编程日记(一)/","content":"前言最近发现一个非常好的项目, 可以练习SpringBoot, SpringCloud微服务还有项目中令人头疼的高并发问题, 是一个技术栈非常全面的java项目. 同时最近学习完了设计模式, 但是仅限于一些简单的代码, 没有在项目当中使用过, 通过本次项目在代码编写的过程中融入设计模式, 还有查漏补缺, 把之前可能遗忘的知识点通过项目实践进行回顾…. 仿12306售票系统编程日记Day0112306 模型设计&amp;逻辑实现余票查询 : 记录站-站余票12306 出色的高并发处理性能离不开它的模型设计, 余票查询中如果按照传统的多表查询, 那么面临每秒几十万次的请求时, 答案只有一个, 立马作废. 余票查询 : 可以理解为是每两个站点之间的票进行销售, 如果购买一张长途的车票, 要做的本质上是n多张两两站点之间的售卖, 将查询变成了单表查询, 极大地提高了查询效率, 而其余余票数量也随某一站点关联增减变化 看个栗子🌰: 假设有5个站点, 分别为A, B, C, D, E, 列车行驶的方向是ABCDE, 那么可供购买的余票方案有几种呢, 这是一个小学问题: 4+3+2+1&#x3D;10种, 假设我们从A-&gt;B有10张票, 那么很显然每一种的票数都是10张, 为什么呢? 因为总共就这10个座位, 再多就只能车顶上站着吹风了! 接着, 如果我们对某两个站点之间的票进行了购买, 那么势必要对其他两个站点之间的余票数量减少, 原因是受到了影响, 有的人疑惑, 这是因为两两站点并非两个相邻站点, 明白这点肯定是理解了. 假设我们买走了A-&gt;B的票, 那么首先A-&gt;B对应的余票就应该减少1, 受到影响的A-&gt;C, A-&gt;D, A-&gt;E都会随之减少1, 这又是为什么呢, 这是因为这里的A-&gt;B, A-&gt;C, A-&gt;D, A-&gt;E不是让你提供方案, 而是已经提出的方案, 箭头两端就是两个站点, 不是原本的固定的路线, 可以参考下图理解一下: 这里往后面多画了一点, 多买了一张C-D的票, 那么按照上面的思路确实是这个样子, 但是实际上并没有这么简单, 因为我们刚才所说的10张票之所以有10张票是因为假设在这趟列车上只有10个座位, 那么就会出现第一张票A-&gt;B和第二张C-D的票购买的是否是在一个座位, 如果在同一个位置, 那么此时A-&gt;D和A-&gt;E的余票仍然是9, 这是因为当你购买第一张票的时候, 已经对A-&gt;D和A-&gt;E造成了影响, 当你再对这个座位的第二张C-&gt;D购买时, 不再对其造成影响, 但是同时会对其他的一些情况造成影响, 可以结合图看一下 通过这张图片我们可以很直观的看出来到底谁受到了影响, 简单来说就是无论座位是否相同, 影响的应该是差集, 这样就可以避免少卖, 因为库存多减少了一嘛 了解过如何避免少卖, 我们应该如何避免多买呢?我们通常可以使用简单的数据结构实现目的, 因为同一个位置, 且在相同站点之间只会有两种可能, 第一种有票, 第二种无票, 所以可以利用数字1和0表示有和没有, 那么座位1的信息在购买了A-&gt;B的余票之后, 信息可以存储为”1000”, 这样我们就可以实现余票数量的存储, 以及方便后续数据存储.","tags":["SpringBoot","微服务","高并发","项目日记","12306"],"categories":["12306售票系统"]}]